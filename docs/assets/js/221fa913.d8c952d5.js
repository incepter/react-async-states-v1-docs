"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[957],{4993:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var a=n(2983);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),d=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=d(e.components);return a.createElement(s.Provider,{value:t},e.children)},p="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},k=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,l=e.originalType,s=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),p=d(n),k=r,m=p["".concat(s,".").concat(k)]||p[k]||c[k]||l;return n?a.createElement(m,i(i({ref:t},u),{},{components:n})):a.createElement(m,i({ref:t},u))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=n.length,i=new Array(l);i[0]=k;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o[p]="string"==typeof e?e:r,i[1]=o;for(var d=2;d<l;d++)i[d]=n[d];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}k.displayName="MDXCreateElement"},4821:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>p,frontMatter:()=>l,metadata:()=>o,toc:()=>d});var a=n(2798),r=(n(2983),n(4993));const l={sidebar_position:4,sidebar_label:"useAsyncState"},i="useAsyncState",o={unversionedId:"api/use-async-state",id:"api/use-async-state",title:"useAsyncState",description:"The useAsyncState hook",source:"@site/docs/api/4-use-async-state.md",sourceDirName:"api",slug:"/api/use-async-state",permalink:"/react-async-states-v1-docs/docs/api/use-async-state",draft:!1,editUrl:"https://github.com/incepter/react-async-states-v1-docs/edit/main/packages/docs/docs/api/4-use-async-state.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4,sidebar_label:"useAsyncState"},sidebar:"tutorialSidebar",previous:{title:"Create source",permalink:"/react-async-states-v1-docs/docs/api/create-source"},next:{title:"useSelector",permalink:"/react-async-states-v1-docs/docs/api/use-selector"}},s={},d=[{value:"The <code>useAsyncState</code> hook",id:"the-useasyncstate-hook",level:2},{value:"Configuration and manipulation",id:"configuration-and-manipulation",level:2},{value:"<code>useAsyncState</code> configuration",id:"useasyncstate-configuration",level:2},{value:"<code>string</code> as the <code>key</code>",id:"string-as-the-key",level:3},{value:"<code>Source</code> object",id:"source-object",level:3},{value:"<code>Producer</code> function",id:"producer-function",level:3},{value:"<code>Configuration</code> object",id:"configuration-object",level:2},{value:"<code>key</code>",id:"key",level:3},{value:"<code>producer</code>",id:"producer",level:3},{value:"<code>initialValue</code>",id:"initialvalue",level:3},{value:"<code>source</code>",id:"source",level:3},{value:"<code>condition</code>",id:"condition",level:3},{value:"<code>lazy</code>",id:"lazy",level:3},{value:"<code>autoRunArgs</code>",id:"autorunargs",level:3},{value:"<code>lane</code>",id:"lane",level:3},{value:"<code>fork</code>",id:"fork",level:3},{value:"<code>forkConfig</code>",id:"forkconfig",level:3},{value:"<code>selector</code>",id:"selector",level:3},{value:"<code>areEqual</code>",id:"areequal",level:3},{value:"<code>runEffect</code>",id:"runeffect",level:3},{value:"<code>runEffectDurationMs</code>",id:"runeffectdurationms",level:3},{value:"<code>skipPendingDelayMs</code>",id:"skippendingdelayms",level:3},{value:"<code>keepPendingForMs</code>",id:"keeppendingforms",level:3},{value:"<code>resetStateOnDispose</code>",id:"resetstateondispose",level:3},{value:"<code>cacheConfig</code>",id:"cacheconfig",level:3},{value:"<code>events</code>",id:"events",level:3},{value:"<code>subscribe</code>",id:"subscribe",level:4},{value:"<code>change</code>",id:"change",level:4},{value:"<code>useAsyncState</code> dependencies",id:"useasyncstate-dependencies",level:2},{value:"<code>useAsyncState</code> return value",id:"useasyncstate-return-value",level:2},{value:"<code>key</code>",id:"key-1",level:3},{value:"<code>source</code>",id:"source-1",level:3},{value:"<code>uniqueId</code>",id:"uniqueid",level:3},{value:"<code>state</code>",id:"state",level:3},{value:"<code>read</code>",id:"read",level:3},{value:"<code>run</code>",id:"run",level:3},{value:"<code>abort</code>",id:"abort",level:3},{value:"<code>invalidateCache</code>",id:"invalidatecache",level:3},{value:"<code>mergePayload</code>",id:"mergepayload",level:3},{value:"<code>setState</code>",id:"setstate",level:3},{value:"<code>lastSuccess</code>",id:"lastsuccess",level:3},{value:"<code>onChange</code>",id:"onchange",level:3},{value:"<code>onSubscribe</code>",id:"onsubscribe",level:3},{value:"Other hooks",id:"other-hooks",level:2}],u={toc:d};function p(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"useasyncstate"},(0,r.kt)("inlineCode",{parentName:"h1"},"useAsyncState")),(0,r.kt)("h2",{id:"the-useasyncstate-hook"},"The ",(0,r.kt)("inlineCode",{parentName:"h2"},"useAsyncState")," hook"),(0,r.kt)("p",null,"This hook allows subscription and full control over a state, and represents\nthe API that you will be using with the most."),(0,r.kt)("p",null,"Its signature is:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"function useAsyncState(configuration, dependencies) {}\n")),(0,r.kt)("p",null,"It returns an object that contains many properties, we'll explore them in a moment."),(0,r.kt)("h2",{id:"configuration-and-manipulation"},"Configuration and manipulation"),(0,r.kt)("p",null,"The configuration argument may be a string, an object with supported properties,\nor a producer function."),(0,r.kt)("p",null,"Let's see in details the supported configuration:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Property"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Default Value"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"key")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"string")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"string")),(0,r.kt)("td",{parentName:"tr",align:null},"The key of the async state we are defining, subscribing to or forking from")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"lazy")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"boolean")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"true")),(0,r.kt)("td",{parentName:"tr",align:null},"If false, the subscription will re-run every dependency change")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"autoRunArgs")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"any[]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"undefined")),(0,r.kt)("td",{parentName:"tr",align:null},"If condition is truthy and lazy is false (automatic), these will the args received by the producer")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"lane")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"string")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"undefined")),(0,r.kt)("td",{parentName:"tr",align:null},"If provided, the subscription will occur to a state Lane, and not the default state")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"fork")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"boolean")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"false")),(0,r.kt)("td",{parentName:"tr",align:null},"If true, subscription will fork the state")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"source")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"object")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"undefined")),(0,r.kt)("td",{parentName:"tr",align:null},"A source object, similar to the one created by ",(0,r.kt)("inlineCode",{parentName:"td"},"createSource"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"producer")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"function")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"undefined")),(0,r.kt)("td",{parentName:"tr",align:null},"The producer function")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"selector")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"function")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"identity")),(0,r.kt)("td",{parentName:"tr",align:null},"receives state (",(0,r.kt)("inlineCode",{parentName:"td"},"{data, args, status}"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"lastSuccess"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"cache"),") and returns the ",(0,r.kt)("inlineCode",{parentName:"td"},"state")," property of the result value")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"areEqual")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"function")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"shallowEqual")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"(prevState, nextState) => areEqual(prevState, nextState)")," determines whether the subscription should update or not")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"condition")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"boolean or ((state: State<T, E, R, A>, args, payload) => boolean)")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"true")),(0,r.kt)("td",{parentName:"tr",align:null},"If this condition is falsy, the automatic run isn't granted. this works only when ",(0,r.kt)("inlineCode",{parentName:"td"},"lazy = false"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"forkConfig")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"ForkConfig")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"{keepState: false, keepCache: false}")),(0,r.kt)("td",{parentName:"tr",align:null},"The fork configuration in case of ",(0,r.kt)("inlineCode",{parentName:"td"},"fork = true"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"cacheConfig")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"CacheConfig")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"undefined")),(0,r.kt)("td",{parentName:"tr",align:null},"Defines the cache config for the producer")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"runEffect")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"RunEffect")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"undefined")),(0,r.kt)("td",{parentName:"tr",align:null},"Defines run effect to decorate the producer with: debounce, throttle, delay...")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"runEffectDurationMs")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"number > 0")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"undefined")),(0,r.kt)("td",{parentName:"tr",align:null},"The duration of the effect in milliseconds")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"resetStateOnDispose")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"boolean")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"true")),(0,r.kt)("td",{parentName:"tr",align:null},"Whether to reset the state to its initial state when all subscribers unsubscribe or to keep it. Default to ",(0,r.kt)("inlineCode",{parentName:"td"},"false"),".")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"skipPendingDelayMs")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"number > 0")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"undefined")),(0,r.kt)("td",{parentName:"tr",align:null},"The duration under which a state update with a pending status may be skipped. The component in this case won't render with a pending status if it gets updated to something else under that delay.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"keepPendingForMs")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"number > 0")," or ",(0,r.kt)("inlineCode",{parentName:"td"},"undefined")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"undefined")),(0,r.kt)("td",{parentName:"tr",align:null},"Once you step in a pending status, it will stay in pending state for this duration. This is supported to push the user experience to newer challenges")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"initialValue")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"any")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"null")),(0,r.kt)("td",{parentName:"tr",align:null},"The initial state value,  the initializer receives the cache as unique parameter")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"events")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"UseAsyncStateEvents")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"undefined")),(0,r.kt)("td",{parentName:"tr",align:null},"Defines events that will be invoked with this subscription.")))),(0,r.kt)("p",null,"The returned object from ",(0,r.kt)("inlineCode",{parentName:"p"},"useAsyncState")," contains the following properties:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Property"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"key")),(0,r.kt)("td",{parentName:"tr",align:null},"the key of the related state instance")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"read(suspend?: boolean = true, throwErr?: boolean = true)")),(0,r.kt)("td",{parentName:"tr",align:null},"returns the selected value and suspends when pending or throws on error")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"state")),(0,r.kt)("td",{parentName:"tr",align:null},"The selected portion of the state")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"lastSuccess")),(0,r.kt)("td",{parentName:"tr",align:null},"the latest registered success state")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"version")),(0,r.kt)("td",{parentName:"tr",align:null},"the version of the state, incremented at each update")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"source")),(0,r.kt)("td",{parentName:"tr",align:null},"a special object hiding the state instance and manipulates it")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"uniqueId")),(0,r.kt)("td",{parentName:"tr",align:null},"the uniqueId of the state instance")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"getState")),(0,r.kt)("td",{parentName:"tr",align:null},"gets the current state")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"setState")),(0,r.kt)("td",{parentName:"tr",align:null},"sets state and notifies all subscribers")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"run")),(0,r.kt)("td",{parentName:"tr",align:null},"runs the producer and returns the abort function")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"runp")),(0,r.kt)("td",{parentName:"tr",align:null},"runs the producer and returns a promise to the run's resolve")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"runc")),(0,r.kt)("td",{parentName:"tr",align:null},"runs the producer with onSuccess, onError and onAborted callbacks")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"replay")),(0,r.kt)("td",{parentName:"tr",align:null},"replays the latest run if exists, or else does nothing")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"abort")),(0,r.kt)("td",{parentName:"tr",align:null},"aborts the current run or clears the abort callbacks if any")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"replaceProducer")),(0,r.kt)("td",{parentName:"tr",align:null},"replaces the producer linked to the state")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"getLaneSource")),(0,r.kt)("td",{parentName:"tr",align:null},"gets the source of a child")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"removeLane")),(0,r.kt)("td",{parentName:"tr",align:null},"removes a lane")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"invalidateCache")),(0,r.kt)("td",{parentName:"tr",align:null},"invalidates a cache entry or the whole cache")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"replaceCache")),(0,r.kt)("td",{parentName:"tr",align:null},"replaces a cache entry")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"mergePayload")),(0,r.kt)("td",{parentName:"tr",align:null},"merges a partial payload inside the state instance's payload")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"subscribe")),(0,r.kt)("td",{parentName:"tr",align:null},"subscribes with a callback to state changes")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"getConfig")),(0,r.kt)("td",{parentName:"tr",align:null},"gets the current used config")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"patchConfig")),(0,r.kt)("td",{parentName:"tr",align:null},"patches the config related to the producer")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"flags")),(0,r.kt)("td",{parentName:"tr",align:null},"the subscription flags number")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"devFlags")),(0,r.kt)("td",{parentName:"tr",align:null},"the subscription flags humanized: listen, source, ...")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"onChange")),(0,r.kt)("td",{parentName:"tr",align:null},"Allows registering one or multiple ",(0,r.kt)("inlineCode",{parentName:"td"},"change")," events at a subscription scope")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"onSubscribe")),(0,r.kt)("td",{parentName:"tr",align:null},"Allows registering one or multiple ",(0,r.kt)("inlineCode",{parentName:"td"},"subscribe")," events at a subscription scope")))),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"Calling the ",(0,r.kt)("inlineCode",{parentName:"p"},"run"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"runp"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"runc")," functions when the status is ",(0,r.kt)("inlineCode",{parentName:"p"},"pending"),"\nwill result in aborting the previous run instantly, and start a new one.")),(0,r.kt)("h2",{id:"useasyncstate-configuration"},(0,r.kt)("inlineCode",{parentName:"h2"},"useAsyncState")," configuration"),(0,r.kt)("h3",{id:"string-as-the-key"},(0,r.kt)("inlineCode",{parentName:"h3"},"string")," as the ",(0,r.kt)("inlineCode",{parentName:"h3"},"key")),(0,r.kt)("p",null,"You may use a ",(0,r.kt)("inlineCode",{parentName:"p"},"string")," as the first parameter to ",(0,r.kt)("inlineCode",{parentName:"p"},"useAsyncState"),"."),(0,r.kt)("p",null,"The key is detailed ",(0,r.kt)("a",{parentName:"p",href:"#key"},"here"),"."),(0,r.kt)("h3",{id:"source-object"},(0,r.kt)("inlineCode",{parentName:"h3"},"Source")," object"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"useAsyncState")," accepts a ",(0,r.kt)("inlineCode",{parentName:"p"},"Source")," object as first parameter."),(0,r.kt)("p",null,"Read about it ",(0,r.kt)("a",{parentName:"p",href:"#source"},"here"),"."),(0,r.kt)("h3",{id:"producer-function"},(0,r.kt)("inlineCode",{parentName:"h3"},"Producer")," function"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"useAsyncState")," accepts a ",(0,r.kt)("inlineCode",{parentName:"p"},"Producer")," function as first parameter."),(0,r.kt)("p",null,"Read about it ",(0,r.kt)("a",{parentName:"p",href:"#/docs/api/producer-function"},"here"),"."),(0,r.kt)("p",null,"You can use it like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"// creates a new non shared state with myProducer as producer\nuseAsyncState(myProducer, [...deps]);\n\n// creates a new non shared state from the given function\nuseAsyncState(function() {\n  // do something\n  // return state value or promise or thenable\n}, [...deps]);\n\n// creates a new non shared state from the given async/await function\nuseAsyncState(async function() {\n  // do something\n  await stuff;\n  // return state value or promise or thenable\n  \n  // or even\n  return await stuff;\n}, [...deps]);\n\n// creates a new non shared state from the given generator\nuseAsyncState(function* myProducer() {\n  // do something\n  yield stuff;\n  // return state value or promise or thenable\n\n  // or even\n  return yield stuff;\n  \n  // or\n  throw e;\n}, [...deps]);\n")),(0,r.kt)("h2",{id:"configuration-object"},(0,r.kt)("inlineCode",{parentName:"h2"},"Configuration")," object"),(0,r.kt)("h3",{id:"key"},(0,r.kt)("inlineCode",{parentName:"h3"},"key")),(0,r.kt)("p",null,"The key received by ",(0,r.kt)("inlineCode",{parentName:"p"},"useAsyncState")," works as the following:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"If the ",(0,r.kt)("inlineCode",{parentName:"li"},"key")," matches something",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Take it and patch the producer and config if given"),(0,r.kt)("li",{parentName:"ul"},"If ",(0,r.kt)("inlineCode",{parentName:"li"},"wait = true"),", wait for a state with that key to be present"),(0,r.kt)("li",{parentName:"ul"},"If ",(0,r.kt)("inlineCode",{parentName:"li"},"fork = true"),", forks from the matched state."))),(0,r.kt)("li",{parentName:"ul"},"If there is no such a ",(0,r.kt)("inlineCode",{parentName:"li"},"key"),", create it with given producer and config, if any")),(0,r.kt)("p",null,"So as a recap, the key is needed:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"When defining a state"),(0,r.kt)("li",{parentName:"ul"},"When trying to subscribe to a state")),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"The previous assumptions are related to ",(0,r.kt)("inlineCode",{parentName:"p"},"key")," only. If a ",(0,r.kt)("inlineCode",{parentName:"p"},"Source")," object is\nprovided, it would just perform ",(0,r.kt)("inlineCode",{parentName:"p"},"subscription")," to it.")),(0,r.kt)("p",null,"The following snippets will give you a good idea of how to ",(0,r.kt)("inlineCode",{parentName:"p"},"useAsyncState"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'import {useAsyncState} from "react-async-states";\n\n// creates a state with `my-key` as key and undefined as producer\nuseAsyncState("my-key");\n\n// will patch the state named my-key with myProducer\nuseAsyncState({\n  key: "my-key",\n  producer: myProducer,\n});\n\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'// listens or waits to the state with `my-key` as key\nuseAsyncState({\n  key: "my-key",\n  producer: myProducer,\n  wait: true,\n});\n\n// the key property is completely ignored\nuseAsyncState({\n  key: "my-key",\n  source: mySource, // assuming this is a valid source object, or else it is like undefined\n});\n\n')),(0,r.kt)("h3",{id:"producer"},(0,r.kt)("inlineCode",{parentName:"h3"},"producer")),(0,r.kt)("p",null,"The production has its ",(0,r.kt)("a",{parentName:"p",href:"/docs/api/producer-function"},"own detailed documentation in this link"),"."),(0,r.kt)("p",null,"If the hook is used like this: ",(0,r.kt)("inlineCode",{parentName:"p"},"useAsyncState(producer)")," it will create a new\nnon-shared state with the given producer and subscribes to it."),(0,r.kt)("p",null,"It can be used like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'import {useAsyncState} from "react-async-states";\n\nuseAsyncState({\n  // the producer property can take any of the supported forms\n  producer: async function (props) {...},\n});\n')),(0,r.kt)("h3",{id:"initialvalue"},(0,r.kt)("inlineCode",{parentName:"h3"},"initialValue")),(0,r.kt)("p",null,"This property is relevant each time creating a new state, and serves as\nthe initializing value of the state (either a value or a function)."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'import {useAsyncState} from "react-async-states";\n\nuseAsyncState({\n  initialValue: 0,\n  producer: counterProducer,\n});\n')),(0,r.kt)("h3",{id:"source"},(0,r.kt)("inlineCode",{parentName:"h3"},"source")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"Source")," objects are retrieved either from ",(0,r.kt)("a",{parentName:"p",href:"/docs/api/create-source"},(0,r.kt)("inlineCode",{parentName:"a"},"createSource")),"\nor from the return value of ",(0,r.kt)("inlineCode",{parentName:"p"},"useAsyncState"),"."),(0,r.kt)("p",null,"It may be used like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'import {createSource, useAsyncState} from "react-async-states";\n\nconst mySource = createSource("my-key", myProducer, myConfig);\n\n// later\n\n// subscribes to the given state\nuseAsyncState(mySource);\n\n// subscribes to the given state\n// all other creation/listen properties are ignored, like key, producer\nuseAsyncState({source: mySource});\n\n// forks the given state\n// all other creation/listen properties are ignored, like key, producer\nuseAsyncState({source: mySource, fork: true});\n')),(0,r.kt)("h3",{id:"condition"},(0,r.kt)("inlineCode",{parentName:"h3"},"condition")),(0,r.kt)("p",null,"This property is used only when ",(0,r.kt)("inlineCode",{parentName:"p"},"lazy")," is ",(0,r.kt)("inlineCode",{parentName:"p"},"falsy"),".\nIf the ",(0,r.kt)("inlineCode",{parentName:"p"},"condition")," is truthy, the ",(0,r.kt)("inlineCode",{parentName:"p"},"producer"),"\nassociated with the subscription will run."),(0,r.kt)("p",null,"It can also be a function that receives the actual state:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"{\n  condition?: boolean | ((state: State<T, E, R>, args, payload) => boolean)\n}\n")),(0,r.kt)("p",null,"This can be very helpful to avoid to setup cache for state instances\nthat only require to run once by the very first subscription."),(0,r.kt)("p",null,"This gives control over the auto run behavior depending on the state."),(0,r.kt)("h3",{id:"lazy"},(0,r.kt)("inlineCode",{parentName:"h3"},"lazy")),(0,r.kt)("p",null,"If this property is set to ",(0,r.kt)("inlineCode",{parentName:"p"},"true"),", when the dependencies change,\nthe ",(0,r.kt)("inlineCode",{parentName:"p"},"producer")," will run if condition is ",(0,r.kt)("inlineCode",{parentName:"p"},"truthy"),"."),(0,r.kt)("admonition",{type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"If several subscriptions are made to the same state and all of them set ",(0,r.kt)("inlineCode",{parentName:"p"},"lazy"),"\nto false, then they may ",(0,r.kt)("inlineCode",{parentName:"p"},"abort")," each other if they have the same dependencies."),(0,r.kt)("p",{parentName:"admonition"},"Pay close attention to this exact use case.")),(0,r.kt)("h3",{id:"autorunargs"},(0,r.kt)("inlineCode",{parentName:"h3"},"autoRunArgs")),(0,r.kt)("p",null,"In case you are opting for a producer that works with ",(0,r.kt)("inlineCode",{parentName:"p"},"args")," and at the same time\nusing ",(0,r.kt)("inlineCode",{parentName:"p"},"useAsyncState")," with ",(0,r.kt)("inlineCode",{parentName:"p"},"lazy=false")," and wish to pass arguments to your producer,\n",(0,r.kt)("inlineCode",{parentName:"p"},"autoRunArgs")," allows this and takes the array of args to the automatic run's producer."),(0,r.kt)("h3",{id:"lane"},(0,r.kt)("inlineCode",{parentName:"h3"},"lane")),(0,r.kt)("p",null,"Lanes are a concept in the library that let's you group states with same producer:"),(0,r.kt)("p",null,"A lane is a totally separate state instance, with own pending state,\nand own payload and subscribers,  and with the same ",(0,r.kt)("inlineCode",{parentName:"p"},"config")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"producer")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"cache"),".\nIt is very similar to forks, but forking means a separated state instance\nnot sharing anything and don't belong to anything."),(0,r.kt)("p",null,"A lane may have multiple subscribers and its own lifecycle."),(0,r.kt)("p",null,"You can manipulate lanes from all the places in the library."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'import {useAsyncState} from "react-async-states";\n\n// subscribes to `city-casablanca` lane in the state defined in `weatherSource`\nuseAsyncState({\n  source: weatherSource,\n  payload: { lat, lng },\n  lane: "city-casablanca"\n});\n\n\n// subscribes to `user-details-me` lane in the state defined in `userDetails`\nuseAsyncState({\n  source: userDetails,\n  payload: { userId: "me" },\n  lane: "user-details-me"\n});\n\n\n// subscribes to `user-details-123` lane in the state defined in `userDetails`\nuseAsyncState({\n  source: userDetails,\n  payload: { userId: "123" },\n  lane: "user-details-123"\n});\n\n// subscribes to `references-company-types` lane in the state defined in `references`\nuseAsyncState({\n  source: references,\n  payload: { userId: "123" },\n  lane: "references-company-types"\n});\n\n')),(0,r.kt)("h3",{id:"fork"},(0,r.kt)("inlineCode",{parentName:"h3"},"fork")),(0,r.kt)("p",null,"If this property is true, it will fork the subscribed state with the given ",(0,r.kt)("inlineCode",{parentName:"p"},"forkConfig"),"."),(0,r.kt)("h3",{id:"forkconfig"},(0,r.kt)("inlineCode",{parentName:"h3"},"forkConfig")),(0,r.kt)("p",null,"A configuration object containing the following:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Property"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Default Value"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"key")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"string")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"undefined")),(0,r.kt)("td",{parentName:"tr",align:null},"The key that will be given to the created state (the forked one)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"keepState")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"boolean")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"undefined")),(0,r.kt)("td",{parentName:"tr",align:null},"Whether to keep the state from the original while forking")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"keepCache")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"boolean")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"undefined")),(0,r.kt)("td",{parentName:"tr",align:null},"Whether to keep the cache from the original while forking")))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'import {useAsyncState} from "react-async-states";\n\n// forks from a Source object and copies its cache\nuseAsyncState({\n  fork: true,\n  source: mySource,\n  forkConfig: {\n    keepCache: true,\n  }\n})\n\n// forks from the subscribed state (by key constraints)\nuseAsyncState({\n  fork: true,\n  key: "some-key",\n  forkConfig: {\n    key: "my-key",\n  }\n})\n')),(0,r.kt)("h3",{id:"selector"},(0,r.kt)("inlineCode",{parentName:"h3"},"selector")),(0,r.kt)("p",null,"The selector that selects data from your state.\nIt is a function with the following in order parameters:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"state")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"State<T>")),(0,r.kt)("td",{parentName:"tr",align:null},"The current state")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"lastSuccess")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"State<T>")),(0,r.kt)("td",{parentName:"tr",align:null},"The last registered state (may be equal to state if the current state is success)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"cache")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Cache<T>")),(0,r.kt)("td",{parentName:"tr",align:null},"The cache associated to this state")))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"// extend the given state\nimport {State, Status, useAsyncState} from \"react-async-states\";\n\n// syncSelector\n// if you want that your state is always synchronous\n// you may be interested only by the data inside the state\nfunction syncSelector(state: State<T>): S {\n  return state.data;\n}\n\n// this selector throws if the state is error so it is leveraged to the nearest\n// error boundary\nfunction errorBoundarySelector(state: State<T>): S {\n  // assuming you have an error boundary\n  if (state.status === Status.error) {\n    throw state.data;\n  }\n  return state;\n}\n\n// this selector gives the last success data\nfunction keepPreviousDataSelector(state: State<T>, lastSuccess): S {\n  if (state.status === Status.pending) {\n    return {\n      ...state,\n      data: lastSuccess.data,\n    };\n  }\n  return state;\n}\n\n// select from cache selector\nfunction errorBoundarySelector(state, lastSuccess, cache): S {\n  // this requires the cache to be enabled\n  if (cache['user-1-details']) {\n    return cache['user-1-details']; // or cache['user-1-details'].data depending or your needs\n  }\n  return state;\n}\n\nfunction lazyDeveloperSelector(state: State<T>) {\n  return {\n    ...state,\n    isError: state.status === Status.error,\n    isPending: state.status === Status.pending,\n    isWeird: false,\n    ...\n  }\n}\n\nconst result = useAsyncState({\n  key,\n  selector: mySelector,\n})\n\n")),(0,r.kt)("h3",{id:"areequal"},(0,r.kt)("inlineCode",{parentName:"h3"},"areEqual")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"areEqual")," function is used to determine whether the previous state value equals\nthe selected value from the new state.\nThis comparison occurs in a callback from React's ",(0,r.kt)("inlineCode",{parentName:"p"},"useState"),". If they are equal\nbased on this function, the old value is used (so react won't trigger an update).\nIf they are different, the new value is used and react will perform a rerender."),(0,r.kt)("h3",{id:"runeffect"},(0,r.kt)("inlineCode",{parentName:"h3"},"runEffect")),(0,r.kt)("p",null,"Defines the effect to apply on the producer while running."),(0,r.kt)("p",null,"This property is only relevant when creating a new state."),(0,r.kt)("p",null,"There are two types of run effects:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"debouce"),": or ",(0,r.kt)("inlineCode",{parentName:"li"},"delay")," and means take the last registered run in the configured duration."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"throttle"),": and means take the first ever run in the duration.")),(0,r.kt)("h3",{id:"runeffectdurationms"},(0,r.kt)("inlineCode",{parentName:"h3"},"runEffectDurationMs")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"runEffectDurationMs")," : the duration of the effect."),(0,r.kt)("p",null,"Here is a working example of debouncing the ",(0,r.kt)("inlineCode",{parentName:"p"},"getClientProducer")," while typing:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'const { run, state } = useAsyncState({\n  producer: getClientProducer,\n\n  runEffect: "debounce",\n  runEffectDurationMs: 500,\n});\n\n// later:\n<input placeholder="User id 1-10" onChange={(e) => run(e.target.value)} />\n\n')),(0,r.kt)("h3",{id:"skippendingdelayms"},(0,r.kt)("inlineCode",{parentName:"h3"},"skipPendingDelayMs")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"skipPendingDelayMs")," : The duration under which a state update with a pending\nstatus may be skipped. The component in this case won't render with a pending\nstatus if it gets updated to something else under that delay."),(0,r.kt)("p",null,"Here is a working example of debouncing the ",(0,r.kt)("inlineCode",{parentName:"p"},"getClientProducer")," while typing:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"// the state won't go to pending if the fetch goes under 300ms!\nconst { run, state } = useAsyncState({\n  skipPendingDelayMs: 300,\n  producer: getClientProducer,\n});\n\n")),(0,r.kt)("h3",{id:"keeppendingforms"},(0,r.kt)("inlineCode",{parentName:"h3"},"keepPendingForMs")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"keepPendingForMs")," : The duration to keep the pending state in to avoid the UI\nflashing if the resolve occurs right after passing the pending by few millis."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"// the pending state will totally be skipped it resolves less than 200ms\n// the state will stay in pending state in at least 500ms\nconst { run, state } = useAsyncState({\n  keepPendingForMs: 500,\n  skipPendingDelayMs: 200,\n  producer: getClientProducer,\n});\n\n")),(0,r.kt)("h3",{id:"resetstateondispose"},(0,r.kt)("inlineCode",{parentName:"h3"},"resetStateOnDispose")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"resetStateOnDispose")," : Defines whether to reset the state to the initial value\nwhen all subscribers unsubcribe, or to keep the current value."),(0,r.kt)("p",null,"The default value is ",(0,r.kt)("inlineCode",{parentName:"p"},"false")," and the library will not reset the state to its\ninitial value by default by convenience."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"const { run, state } = useAsyncState({\n  resetStateOnDispose: true,\n  producer: getClientProducer,\n});\n\n\n// or\n\ncreateSource(key, producer, {resetStateOnDispose: true});\n")),(0,r.kt)("h3",{id:"cacheconfig"},(0,r.kt)("inlineCode",{parentName:"h3"},"cacheConfig")),(0,r.kt)("p",null,"It determines the cache configurations:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Property"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"enabled")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"boolean")),(0,r.kt)("td",{parentName:"tr",align:null},"Whether to enable cache or not")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"hash")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"(args?: any[], payload?: {[id: string]: any} or null) => string")),(0,r.kt)("td",{parentName:"tr",align:null},"a function to calculate a hash for a producer run (from args and payload)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"getDeadline")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"(currentState: State<T>) => number")),(0,r.kt)("td",{parentName:"tr",align:null},"returns the deadline after which the cache is invalid")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"load")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"() => {[id: string]: CachedState<T>}")),(0,r.kt)("td",{parentName:"tr",align:null},"loads the cached data when the async state instance is created")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"persist")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"(cache: {[id: string]: CachedState<T>}) => void")),(0,r.kt)("td",{parentName:"tr",align:null},"a function to persist the whole cache, called when state is updated to success")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"onCacheLoad")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"onCacheLoad?({cache, setState}): void")),(0,r.kt)("td",{parentName:"tr",align:null},"a callback called when the cache loads, useful when asynchronously loading cache")))),(0,r.kt)("h3",{id:"events"},(0,r.kt)("inlineCode",{parentName:"h3"},"events")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"events")," property defines handlers that will be invoked."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"export type UseAsyncStateEvents<T> = {\n  change?: UseAsyncStateEventFn<T> | UseAsyncStateEventFn<T>[],\n  subscribe?: ((props: SubscribeEventProps<T>) => CleanupFn) | ((props: SubscribeEventProps<T>) => CleanupFn)[],\n}\n")),(0,r.kt)("p",null,"The supported events are:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"subscribe"),": invoked when a subscription to a state occurs."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"change"),": invoked whenever the state value changes. Always invoked, even if\n",(0,r.kt)("inlineCode",{parentName:"li"},"areEqual")," is truthy.")),(0,r.kt)("h4",{id:"subscribe"},(0,r.kt)("inlineCode",{parentName:"h4"},"subscribe")),(0,r.kt)("p",null,"This event handler is called once a subscription to a state occurs."),(0,r.kt)("p",null,"This should be mainly used to attach event listeners that may ",(0,r.kt)("inlineCode",{parentName:"p"},"run")," the producer\nor do another side effect."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"// this is how the library invokes the subscribe events.\nunsubscribe = subscribe(sourceObject);\n")),(0,r.kt)("p",null,"This functions returns its cleanup (if available.)"),(0,r.kt)("p",null,"Here is an example of how to use it to run your producer once your window gets focused:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'const {state: {status, data}, lastSuccess, abort} = useAsyncState({\n    lazy: false,\n    payload: {matchParams: params},\n    key: demoAsyncStates.getUser.key,\n    events: {\n      subscribe: ({getState, run, invalidateCache}) => {\n        const state = getState();\n        function onFocus() {\n          if (shouldInvalidateCacheAndRun()) {\n            invalidateCache();\n            run();\n          }\n        }\n        window.addEventListener("focus", onFocus);\n        return () => window.removeEventListener("focus", onFocus);\n      },\n    }\n  }, [params]);\n')),(0,r.kt)("h4",{id:"change"},(0,r.kt)("inlineCode",{parentName:"h4"},"change")),(0,r.kt)("p",null,"This event handler is called when the state changes."),(0,r.kt)("p",null,'Please note that these handlers are invoked after subscription to a state,\nso they will miss any state update when "',(0,r.kt)("inlineCode",{parentName:"p"},"not subscribed"),'". Although, this\nmay change in the future and also the events function could be granted the producer\npower.'),(0,r.kt)("p",null,"This should be mainly used to run side effects after a ",(0,r.kt)("inlineCode",{parentName:"p"},"status")," change."),(0,r.kt)("p",null,"Here are some examples of how to use it:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'const {state: {status, data}, lastSuccess, abort} = useAsyncState({\n    lazy: false,\n    payload: {matchParams: params},\n    key: demoAsyncStates.updateUser.key,\n    events: {\n      change: ({state, source}: {state: State, source: Source}) => {\n        if (state.status === "success") {\n          refreshList();\n          closeModal();\n        }\n      },\n    }\n  }, [params]);\n')),(0,r.kt)("h2",{id:"useasyncstate-dependencies"},(0,r.kt)("inlineCode",{parentName:"h2"},"useAsyncState")," dependencies"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"useAsyncState")," accepts a second parameter that corresponds to the array of its\ndependencies.\nThe default value is empty array rather that undefined."),(0,r.kt)("p",null,"The dependencies are the secure vault over closure variables that you make, so\nalways be sure to add them responsibly."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'import {useAsyncState} from "react-async-states";\n\nconst params = useParams;\nuseAsyncState(function getUserDetails(props) {\n  doSomethingWith(params)\n  return stateValue;\n}, [\n  params,// whenever params change, recreate the state\n]);\n\n// OR USING PAYLOAD\nfunction callback() {}\nuseAsyncState({\n  payload: {params, callback},\n  producer(props) {\n    const {params} = props.payload;\n    callback();\n  },\n}, [\n  params,\n  callback,\n]);\n')),(0,r.kt)("admonition",{type:"warning"},(0,r.kt)("p",{parentName:"admonition"},"Be sure to add relevant component variables used in the subscription as\ndependencies or you will have unwanted behavior and hard to debug/spot bugs.")),(0,r.kt)("h2",{id:"useasyncstate-return-value"},(0,r.kt)("inlineCode",{parentName:"h2"},"useAsyncState")," return value"),(0,r.kt)("h3",{id:"key-1"},(0,r.kt)("inlineCode",{parentName:"h3"},"key")),(0,r.kt)("p",null,"Corresponds to the key of the ",(0,r.kt)("inlineCode",{parentName:"p"},"AsyncState")," instance that you subscribed to."),(0,r.kt)("p",null,"For example, if you choose to fork a state while omitting the fork key, an\nautomatic key will be given. You'll need that ",(0,r.kt)("inlineCode",{parentName:"p"},"key")," or the ",(0,r.kt)("inlineCode",{parentName:"p"},"source")," to be able\nto subscribe to it."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'import {useAsyncState} from "react-async-states";\n\nconst {key} = useAsyncState();\n')),(0,r.kt)("h3",{id:"source-1"},(0,r.kt)("inlineCode",{parentName:"h3"},"source")),(0,r.kt)("p",null,"This is the same object given by ",(0,r.kt)("a",{parentName:"p",href:"/docs/api/create-source"},(0,r.kt)("inlineCode",{parentName:"a"},"createSource")),"\nand it shall allow further subscription to the state."),(0,r.kt)("p",null,"Why does source and key both exist:"),(0,r.kt)("p",null,"The library doesn't use any global store to keep a reference towards created\nstates, so they will be garbage collected immediately after loosing developer\nreference towards them. THe source object contains the instance of state,\nby providing it back to the library, it knows how unwrap it and perform\nsubscription and/or run it."),(0,r.kt)("p",null,"Plus, ",(0,r.kt)("inlineCode",{parentName:"p"},"createSource")," doesn't need react to work, so it will allow creating\nmodule level states. Also, the library support running producers and states\nfrom almost everywhere in your code base, and it would just work if you provid\na ",(0,r.kt)("inlineCode",{parentName:"p"},"Source")," object."),(0,r.kt)("p",null,"The source object has the following properties:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Property"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"key")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"string")),(0,r.kt)("td",{parentName:"tr",align:null},"the provided key of the state instance")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"run")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"function(...args[])")),(0,r.kt)("td",{parentName:"tr",align:null},"A function that runs the producer attached to the source")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"getState")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"() => State<T>")),(0,r.kt)("td",{parentName:"tr",align:null},"returns the current state of the source object")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"getLaneSource")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"(lane?: string) => Source<T>")),(0,r.kt)("td",{parentName:"tr",align:null},"returns a ",(0,r.kt)("inlineCode",{parentName:"td"},"source")," object for the given lane")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"setState")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"((t: T) => void) or (prev: State<T>, status) => T")),(0,r.kt)("td",{parentName:"tr",align:null},"replaces the current state with the value or the provided updater function")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"invalidateCache")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"(cacheKey?: string) => void")),(0,r.kt)("td",{parentName:"tr",align:null},"invalidates the given cache by key or the whole cache")))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'import {useAsyncState} from "react-async-states";\n\nconst {source} = useAsyncState();\n')),(0,r.kt)("h3",{id:"uniqueid"},(0,r.kt)("inlineCode",{parentName:"h3"},"uniqueId")),(0,r.kt)("p",null,"This is only used in development mode and was originally added with the devtools."),(0,r.kt)("p",null,"In general, you would never use this (unless you are a contributor and debugging things)."),(0,r.kt)("h3",{id:"state"},(0,r.kt)("inlineCode",{parentName:"h3"},"state")),(0,r.kt)("p",null,"This is whatever the selector returns:"),(0,r.kt)("p",null,"The selector is described in ",(0,r.kt)("a",{parentName:"p",href:"#selector"},"its own section"),"."),(0,r.kt)("p",null,"The default selector of the library returns the ",(0,r.kt)("inlineCode",{parentName:"p"},"State")," identity, which is\ncomposed of:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Property"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"data")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"T")),(0,r.kt)("td",{parentName:"tr",align:null},"The returned data from the ",(0,r.kt)("inlineCode",{parentName:"td"},"producer function"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"status")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"initial,pending,success,error,aborted")),(0,r.kt)("td",{parentName:"tr",align:null},"The status of the state")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"props")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"ProducerProps")),(0,r.kt)("td",{parentName:"tr",align:null},"The argument object that the producer was ran with (the ",(0,r.kt)("inlineCode",{parentName:"td"},"props"),")")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"timestamp")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"number")),(0,r.kt)("td",{parentName:"tr",align:null},"the time (",(0,r.kt)("inlineCode",{parentName:"td"},"Date.now()"),") where the state was constructed")))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'import {State, useAsyncState} from "react-async-states";\n\ntype User = {\n  name: string,\n}\n\nfunction myProducer(): Promise<User> {\n  return fetch(url).then(r => r.json());\n}\n\nfunction userNameSelector(state: State<User>): string | null {\n  return state.status === "success" ? state.data.name : null;\n}\n\n// later:\nconst {state} = useAsyncState(myProducer);\n\n\n// state in this case is a string\nconst {state: userName} = useAsyncState({\n  producer: myProducer,\n  selector: mySelector,\n})\n\n\nfunction defaultLibrarySelector(...args): State<T> {\n  return args[0];\n}\n\n')),(0,r.kt)("h3",{id:"read"},(0,r.kt)("inlineCode",{parentName:"h3"},"read")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"read(suspend?: boolean = true, throwError?: boolean = true);\n")),(0,r.kt)("p",null,"This function enable the react's concurrent feature: ",(0,r.kt)("inlineCode",{parentName:"p"},"Component suspension")," and\n",(0,r.kt)("inlineCode",{parentName:"p"},"Error boundary"),"."),(0,r.kt)("p",null,"So calling read requires you to have a ",(0,r.kt)("inlineCode",{parentName:"p"},"Suspense")," and/or ",(0,r.kt)("inlineCode",{parentName:"p"},"ErrorBoundary"),"\nup in your tree."),(0,r.kt)("p",null,"You can pass this function to a child component that will read the data and\nsuspend if pending."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},'import {Suspense} from "react";\nimport {useAsyncState} from "react-async-states";\n\n\nfunction UserDetails({userId}) {\n  \n  const {read, state} = useAsyncState({\n    lazy: false,\n    payload: {userId},\n    source: userDetailsPageSource,\n  }, [userId]);\n  \n  \n  return (\n    <Suspense fallback={<Skeleton userId={userId} />}>\n      <ErrorBoundary>\n        <UserDetails read={read} />\n      </ErrorBoundary>\n    </Suspense>\n  );\n}\n\nfunction UserDetails({read}) {\n  // when pending, this line will throw a Promise that react will catch\n  // and display Suspense\'s fallback until present\n  const {data, status} = read();\n  \n  return (\n    // build the UI based on the statuses you need\n  );\n}\n\n')),(0,r.kt)("h3",{id:"run"},(0,r.kt)("inlineCode",{parentName:"h3"},"run")),(0,r.kt)("p",null,"This function triggers the producer run."),(0,r.kt)("p",null,"It gives to the producer whatever it was called with as ",(0,r.kt)("inlineCode",{parentName:"p"},"args"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'\n// calling run like this\nrun(1, 2, 3);\n// should be reflected like this for the producer when running:\nprops = {\n  // ...\n  args: [1, 2, 3]\n  // ...\n}\n        \n// calling run like this\nrun(1, 2, 3);\n// should be reflected like this for the producer when running:\nprops = {\n  // ...\n  args: [1, 2, 3]\n  // ...\n}\n\n// calling run like this\nrun();\n// should be reflected like this for the producer when running:\nprops = {\n  // ...\n  args: []\n  // ...\n}\n\n// calling run like this\nrun("increment", 1);\n// should be reflected like this for the producer when running:\nprops = {\n  // ...\n  args: ["increment", 1]\n  // ...\n}\n\n// calling run like this\nrun(1, {name: "John"});\n// should be reflected like this for the producer when running:\nprops = {\n  // ...\n  args: [1, {name: "John"}]\n  // ...\n}\n\n')),(0,r.kt)("h3",{id:"abort"},(0,r.kt)("inlineCode",{parentName:"h3"},"abort")),(0,r.kt)("p",null,"the ",(0,r.kt)("inlineCode",{parentName:"p"},"abort")," function when called, if the status is pending, it would trigger\nthe abort, and execute all registered abort callbacks."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},'import {useAsyncState} from "react-async-states";\n\nconst {state: {status}, abort} = useAsyncState("my-key");\n\n{status === "pending" && <Button onClick={() => abort("user_action")}>Abort</Button>}\n')),(0,r.kt)("h3",{id:"invalidatecache"},(0,r.kt)("inlineCode",{parentName:"h3"},"invalidateCache")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"invalidateCache: (cacheKey?: string) => void\n")),(0,r.kt)("p",null,"Takes an optional ",(0,r.kt)("inlineCode",{parentName:"p"},"cacheKey")," parameter that:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"If provided, will delete the cache entry from cache."),(0,r.kt)("li",{parentName:"ul"},"If not provided, will delete the whole cache.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},'import {useAsyncState} from "react-async-states";\n\nconst {invalidateCache} =  useAsyncState({\n  source: usersPageSource,\n});\n\n<Button onClick={() => {\n  invalidateCache();\n  run()\n}}>Reset search</Button>\n')),(0,r.kt)("h3",{id:"mergepayload"},(0,r.kt)("inlineCode",{parentName:"h3"},"mergePayload")),(0,r.kt)("p",null,"The payload that the producer returns is the payload issued from all subscribers,\nand the one that this function adds:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'import {useAsyncState} from "react-async-states/src";\n\nconst {mergePayload} = useAsyncState();\n\nmergePayload({userId: 1, isNew: false});\n\n// payload is {userId: 1, isNew: false}\n\nmergePayload({count: 3, userId: 5});\n\n// payload is {count: 3, userId: 5, isNew: fale}\n')),(0,r.kt)("h3",{id:"setstate"},(0,r.kt)("inlineCode",{parentName:"h3"},"setState")),(0,r.kt)("p",null,"setState is of a : ",(0,r.kt)("inlineCode",{parentName:"p"},"StateUpdater"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"type StateUpdater<T> = (\n  updater: T | StateFunctionUpdater<T>,\n  status?: Status\n) => void;\n")),(0,r.kt)("p",null,"It just puts a value as the current state."),(0,r.kt)("h3",{id:"lastsuccess"},(0,r.kt)("inlineCode",{parentName:"h3"},"lastSuccess")),(0,r.kt)("p",null,"This points to the last state with status ",(0,r.kt)("inlineCode",{parentName:"p"},"success"),"."),(0,r.kt)("p",null,"So if state is actually with a success state, they are the same object."),(0,r.kt)("p",null,"You can use it if you want to be sure in a component that you interact with\na state of type success all the time:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},'import {useAsyncState} from "react-async-states";\n\nconst {state: {status, props, data}, lastSuccess} = useAsyncState(myConfig);\n\n// You can think of the following UI, that\n// always display the data in the background\n// when pending or error it just displays an error on top of it\n<MyContainer>\n  <MyData data={lastSuccess} />\n  <ErrorOverlay data={data} visible={status === "error"} />\n  <PendingOverlay data={props} visible={status === "pending"} />\n< /MyContainer>\n')),(0,r.kt)("h3",{id:"onchange"},(0,r.kt)("inlineCode",{parentName:"h3"},"onChange")),(0,r.kt)("p",null,"This injects additional change ",(0,r.kt)("inlineCode",{parentName:"p"},"events"),", and can be called during render or\nimperatively anywhere. These events live just with the current subscription."),(0,r.kt)("h3",{id:"onsubscribe"},(0,r.kt)("inlineCode",{parentName:"h3"},"onSubscribe")),(0,r.kt)("p",null,"This injects additional subscribe ",(0,r.kt)("inlineCode",{parentName:"p"},"events"),", and can be called during render or\nimperatively anywhere. These events live just with the current subscription."),(0,r.kt)("h2",{id:"other-hooks"},"Other hooks"),(0,r.kt)("p",null,"For convenience, we've added many other hooks with ",(0,r.kt)("inlineCode",{parentName:"p"},"useAsyncState")," to help inline most of the situations: They inject\na configuration property which may facilitate using the library:"),(0,r.kt)("p",null,"The following are all hooks with the same signature as ",(0,r.kt)("inlineCode",{parentName:"p"},"useAsyncState"),", but each predefines something in the configuration:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"useAsyncState.auto"),": adds ",(0,r.kt)("inlineCode",{parentName:"li"},"lazy: false")," to configuration"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"useAsyncState.lazy"),": adds ",(0,r.kt)("inlineCode",{parentName:"li"},"lazy: true")," to configuration"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"useAsyncState.fork"),": adds ",(0,r.kt)("inlineCode",{parentName:"li"},"fork: true")," to configuration"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"useAsyncState.forkAudo"),": adds ",(0,r.kt)("inlineCode",{parentName:"li"},"lazy: false, fork: true")," to configuration")),(0,r.kt)("p",null,"The following snippets results from the previous hooks:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"// automatically fetches the user's list when the search url changes\nconst {state: {status, data}, run, abort} = useAsyncState.auto(DOMAIN_USER_PRODUCERS.list.key, [search]);\n// automatically fetches user 1 and selects data\nconst {state: user1} = useAsyncState.auto({source: user1Source, selector: s => s.data});\n// automatically fetches user 2 and selects its name\nconst {state: user2} = useAsyncState.auto({source: user2Source, selector: name});\n// forks userPayloadSource and runs it automatically with a new payload and selects the name from result\nconst {state: user4} = useAsyncState.forkAuto({source: userPayloadSource, payload: {userId: 4}, selector: name})\n")),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"To suspend a component in concurrent mode, or throw to error boundary on error,\njust call the ",(0,r.kt)("inlineCode",{parentName:"p"},"read")," function returned by ",(0,r.kt)("inlineCode",{parentName:"p"},"useAsyncState")," or any other hook.")))}p.isMDXComponent=!0}}]);
