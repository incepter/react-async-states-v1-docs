"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[120],{4993:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>f});var a=n(2983);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},s=Object.keys(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=a.createContext({}),l=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=l(e.components);return a.createElement(c.Provider,{value:t},e.children)},h="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,s=e.originalType,c=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),h=l(n),p=r,f=h["".concat(c,".").concat(p)]||h[p]||d[p]||s;return n?a.createElement(f,o(o({ref:t},u),{},{components:n})):a.createElement(f,o({ref:t},u))}));function f(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var s=n.length,o=new Array(s);o[0]=p;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i[h]="string"==typeof e?e:r,o[1]=i;for(var l=2;l<s;l++)o[l]=n[l];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},2355:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>i,toc:()=>l});var a=n(2798),r=(n(2983),n(4993));const s={sidebar_position:1,sidebar_label:"TL;DR"},o="TL;DR",i={unversionedId:"api/the-whole-api",id:"api/the-whole-api",title:"TL;DR",description:"useAsyncState",source:"@site/docs/api/0-the-whole-api.md",sourceDirName:"api",slug:"/api/the-whole-api",permalink:"/react-async-states-v1-docs/docs/api/the-whole-api",draft:!1,editUrl:"https://github.com/incepter/react-async-states-v1-docs/edit/main/packages/docs/docs/api/0-the-whole-api.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1,sidebar_label:"TL;DR"},sidebar:"tutorialSidebar",previous:{title:"State sharing",permalink:"/react-async-states-v1-docs/docs/tutorial/state-sharing"},next:{title:"The producer function",permalink:"/react-async-states-v1-docs/docs/api/producer-function"}},c={},l=[{value:"<code>useAsyncState</code>",id:"useasyncstate",level:2},{value:"<code>producer</code>",id:"producer",level:2},{value:"<code>createSource</code>",id:"createsource",level:2}],u={toc:l};function h(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"tldr"},"TL;DR"),(0,r.kt)("h2",{id:"useasyncstate"},(0,r.kt)("inlineCode",{parentName:"h2"},"useAsyncState")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"const {\n  read, // returns the selected value and suspends when pending\n  state, // The selected portion of the state\n  lastSuccess, // the latest registered success state\n  version, // the version of the state, incremented at each update\n  source, // a special object hiding the state instance and manipulates it\n  key, // the key of the related state instance\n  uniqueId, // the uniqueId of the state instance\n  getState, // gets the current state\n  setState, // sets state and notifies all subscribers\n  on, // allows registering events at `source` (state instance) level\n  run, // runs the producer and returns the abort function\n  runp, // runs the producer and returns a promise to the run's resolve\n  runc, // runs the producer with onSuccess, onError and onAborted callbacks\n  replay, // replays the latest run if exists, or else does nothing\n  abort, // aborts the current run or clears the abort callbacks if any\n  replaceProducer, // replaces the producer linked to the state\n  hasLane, // returns true if the given lane key exists\n  getLaneSource, // gets the source of a child lane\n  removeLane, // removes a lane\n  invalidateCache, // invalidates a cache entry or the whole cache\n  replaceCache, // replaces a cache entry\n  mergePayload, // merges a partial payload inside the state instance's payload\n  subscribe, // subscribes with a callback to state changes\n  getConfig, // gets the current used config\n  patchConfig, // patches the config related to the producer\n  flags, // the subscription mode: listen, source, hoist, ...\n  devFlags, // the subscription mode: listen, source, hoist, ...\n  onChange, // Register `events.change` relative to the current subscription that will called when state changes \n  onSubscribe, // Register `events.subscribe` relative to the current subscription\n} = useAsyncState({\n  key, // the subscription key or the definition key\n  lane, // the lane instance to use\n  source, // the source object received from createSource or a subscription\n  payload, // the payload to merge in the instance\n  producer, // the producer to be defined in the state instance\n  skipPendingDelayMs, // skips the pending status under that delay in Ms\n  keepPendingForMs, // stays in the pending state for this duration (to avoid the UI flashing)\n  skipPendingStatus, // never sets the status to pending, it will always notify only about resolve/abort\n  cacheConfig: {\n    enabled, // whether to enable cache or not\n    getDeadline, // get the cache deadline for a succeeded state\n    hash, // hashes the run task to add a cache entry\n    persist, // persists the whole cache\n    load, // loads the cache\n    onCacheLoad, // callback called when cache loads\n  },\n  runEffect, // the effect to apply on runs (debounce, delay, throttle..)\n  runEffectDurationMs, // the duration of the run effect in Ms\n  resetStateOnDispose, // whether to reset state to initial status when no subscribers are left\n  initialValue, // the initial value when creating an instance\n  fork, // whether to fork in given instnace\n  forkConfig: {\n    key, // the key to give to the new instance\n    keepState, // copy the state from the initial instance\n    keepCache, // copy the cache from the initial instance\n  },\n  lazy, // whether to automatically run the producer if the condition is truthy\n  autoRunArgs, // the args to give to the producer when auto running\n  condition, // whether should auto run or not\n  areEqual, // compares the previous and next selected value when state changes\n  subscriptionKey, // the subscription key that will appear in devtools for this usage\n  selector, // the selector\n  wait, // When providing a string key, you can wait for it if it doesn't exist via this property\n  events: { // registers events\n    change: { // called whenever state changes, may be a function, an object, or an array of either\n      status, // the status at which this event should be invoked\n      handler, // the event handler\n    }, // | (newState: State<T>) => void,\n    // called when the subscription to the state instance occurs,\n    // may be used to attach global events such as focus, scroll etc\n    subscribe, // may be a function or an array of them\n  },\n});\n")),(0,r.kt)("h2",{id:"producer"},(0,r.kt)("inlineCode",{parentName:"h2"},"producer")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"function myProducer<T>({\n  args, // the array of args given to the run function\n  payload, // the payload held by the state instance\n  abort, // will abort its own run\n  onAbort, // registers abort/cleanup callbacks\n\n  isAborted, // returns whether this run was aborted\n  getState, // gives the current state at any point of time (may be used before emit)\n  emit, // replaces state, works after resolve to support streaming/incremental resolve\n  lastSuccess, // the last success that was registered before this call, useful for reducers & infinite data\n  run, // runs a source or an instance or a producer and returns the abort function\n  runp, // runs a source or an instance or a producer and returns a promise to resolve\n  select, // selects from source or by key the current state of any state instance\n}) {\n  return T | Promise<T> | Generator<any, T, any>;\n}\n")),(0,r.kt)("h2",{id:"createsource"},(0,r.kt)("inlineCode",{parentName:"h2"},"createSource")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"const source = createSource(\n  \"my key\",\n  myProducer,\n  {\n    initialValue, // the initial value, may be a function receiving cache a state setter\n    runEffect, // the effect to apply on runs (debounce, delay, throttle..)\n    runEffectDurationMs, // the duration of the run effect in Ms\n    resetStateOnDispose, // whether to reset state to initial status when no subscribers are left\n    skipPendingDelayMs, // skips the pending status under that delay in Ms\n    keepPendingForMs, // stays in the pending state for this duration (to avoid the UI flashing)\n    skippendingStatus, // skips totally any pending status\n    hideFromDevtools, // hides this state from the devtools\n    cacheConfig: {\n      enabled, // whether to enable cache or not\n      getDeadline, // get the cache deadline for a succeeded state\n      hash, // hashes the run task to add a cache entry\n      persist, // persists the whole cache\n      load, // loads the cache\n      onCacheLoad, // callback called when cache loads\n    },\n  }\n);\n\nlet {\n  key, // the key of the related state instance\n  uniqueId, // the uniqueId of the state instance\n  getState, // gets the current state\n  setState, // sets state and notifies all subscribers\n  run, // runs the producer and returns the abort function\n  runp, // runs the producer and returns a promise to the run's resolve\n  runc, // runs the producer with onSuccess, onError and onAborted callbacks\n  replay, // replays the latest run if exists, or else does nothing\n  on, // allows registering events at `source` (state instance) level\n  abort, // aborts the current run or clears the abort callbacks if any\n  replaceProducer, // replaces the producer linked to the state\n  hasLane, // returns true if the given lane key exists\n  getLaneSource, // gets the source of a child\n  removeLane, // removes a lane\n  invalidateCache, // invalidates a cache entry or the whole cache\n  replaceCache, // replaces a cache entry\n  mergePayload, // merges a partial payload inside the state instance's payload\n  subscribe, // subscribes with a callback to state changes\n  getConfig, // gets the current used config\n  patchConfig, // patches the config related to the producer\n} = source;\n")))}h.isMDXComponent=!0}}]);
